# Analysis of algorithms using the RAM model of computation

1. Measuring the running time of an algorithm
2. Primitive Operations
3. Worst, Average, Best Case Analysis


## Purpose of analysing algorithms

- Is it correct? 

- Is it efficient
	- Time taken
	- Spaced utilised

- Can it be improved

## Factors impacting running times of algorithms

- Speed of the machine

- Programming Language Used
	- Example: Assembly is faster than C, which is faster than Java

- Efficiency of the compiler

- The size of the input

- Organisation of the input
	- How much does the input have to be processed

A general metric for time efficiency is needed which is independent of language and processor speed or compiler efficiency

## Methods of analysis

### Experimental Studies

- Write a program implementing the algorithm
- Run the program with different inputs
- Use a method / utility to get an accurate measure of running time
- Plot the results and analyse them

- Limitations of Experiments
	- It is necessary to implement the algorithm which may be complex
	- Experiments are limited to specified inputs
	- To compare results, the same hardware and software environments are required

### Theoretical Analysis

- General Methodology
- Uses a high level of explanation of the algorithm
- Characterises run time as a function of the input size, n
- Takes into account all posible inputs
- Independent of the hardware of software environment

## Primitive Operations

- To analyse an algorithm we can count these operations
- Can be identified in pseudo-code

- Example operations
	- Evaluating expressions: 2 + 2
	- Assigning values: X <- 3
	- Array indexing: array[2]
	- Calling functions: function()
	- Returning values











	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
